import abc as абц
import builtins as встроенные
import pathlib as путьбиб
import re as ре
from collections import defaultdict as умолчслов
from dataclasses import dataclass as классданных
from typing import Self as Сам

import исключения as ис
from операции import питон
from программа import Программа
from типы import Ничего, Список, Мб

ПЕРЕМ_ШАБЛОН = r"^заряжаем\s+(\w+)\s*=\s*([\w\s\+\-\*/]+)"
ВЫЗОВ_ФУНК_ШАБЛОН = r"^говорим\((.*?)\)"

_йоты = умолчслов(lambda: -1)


def _йота(имя: str, сброс: bool = False) -> int:
    global _йоты

    if сброс:
        _йоты[имя] = 0
    else:
        _йоты[имя] += 1
    return _йоты[имя]


class Токен(абц.ABC):

    @classmethod
    @абц.abstractmethod 
    def попробуй_из_строки(клс, стр: str) -> Мб[Сам]: ...


@классданных
class ТкнОбъявлениеПеременной(Токен):
    имя: str
    значение: str

    @classmethod
    def попробуй_из_строки(клс, стр: str) -> Мб[Сам]:
        if соотв := ре.match(ПЕРЕМ_ШАБЛОН, стр):
            return клс(имя=соотв.group(1), значение=соотв.group(2))
        return Ничего


@классданных
class ТкнВызовФункции(Токен):
    имя: str
    аргументы: Список[str]

    @classmethod
    def попробуй_из_строки(клс, стр: str) -> Мб[Сам]:
        if соотв := ре.match(ВЫЗОВ_ФУНК_ШАБЛОН, стр):
            return клс(имя="print", аргументы=[соотв.group(1)])
        return Ничего


class ТкнДокажу(Токен):

    @classmethod
    def попробуй_из_строки(клс, стр: str) -> Мб[Сам]:
        if ре.match("^докажу", стр):
            return клс()
        return Ничего


class Парсер:

    _ТОКЕН_ТИПЫ = [
        ТкнОбъявлениеПеременной, 
        ТкнВызовФункции,
        ТкнДокажу,
    ]

    def __init__(сам, файл: путьбиб.Path):
        сам.файл = файл

    def получить_программу(сам) -> Программа:
        содержание = сам.файл.read_text()
        строки = содержание.splitlines()
        ошибки_комп = []

        парс_рез = [сам.спарсить_строку(стр, ном_строки) for ном_строки, стр in enumerate(строки, 1)]
        ошибки_комп.extend(об for об in парс_рез if isinstance(об, ис.Искл))
        токены = [об for об in парс_рез if isinstance(об, Токен)]

        операции = []
        имя_к_ид_знач = {}
        таблица_конст = {}

        операции.append(питон.Вернуть(0))
        таблица_конст[Ничего] = _йота("таблица_конст")

        for токен in токены:
            match токен:
                case ТкнОбъявлениеПеременной(имя, значение):
                    if значение.isdigit(): значение = int(значение)

                    if имя not in имя_к_ид_знач:
                        имя_к_ид_знач[имя] = (_йота("имя_к_ид_знач"), Ничего)
                    if значение not in таблица_конст:
                        таблица_конст[значение] = _йота("таблица_конст")

                    ид_имени = имя_к_ид_знач[имя][0]
                    ид_константы = таблица_конст[значение]
                    операции.extend([
                        питон.ЗагрКонст(ид_константы),
                        питон.СохрКакИмя(ид_имени),
                    ])
                case ТкнВызовФункции(имя, аргументы):
                    if имя not in имя_к_ид_знач:
                        имя_к_ид_знач[имя] = (_йота("имя_к_ид_знач"), встроенные.print)

                    ид_функции = имя_к_ид_знач[имя][0]
                    ид_константы = имя_к_ид_знач[аргументы[0]][0]
                    операции.extend([
                        питон.ТолкнутьНуль(),
                        питон.ЗагрИмя(ид_функции),
                        питон.ЗагрИмя(ид_константы),
                        питон.Вызвать(1),
                    ])
                case _: 
                    ошибки_комп.append(ис.НеразрешенныйТокен(токен))

        if ошибки_комп:
            raise ис.ОшибкаКомп(ошибки_комп)
        операции.extend([
            питон.ТянутьВерхушку(),
            питон.ВернутьКонст(0),
        ])
                    
        таблица_имен = {
            ид: (имя, знач)
            for имя, (ид, знач) in имя_к_ид_знач.items()
        }
        конст_пул = tuple(знач for знач in sorted(таблица_конст, key=таблица_конст.get))
        return Программа(операции, таблица_имен, конст_пул)

    @classmethod
    def спарсить_строку(клс, стр: str, ном_строки: int) -> Токен | ис.Искл:
        for тип in клс._ТОКЕН_ТИПЫ:
            мбтокен = тип.попробуй_из_строки(стр)
            if мбтокен is not Ничего:
                return мбтокен
        return ис.НеверноеВыражение(стр, ном_строки)

