import pathlib as путьбиб
import re as ре
from dataclasses import dataclass as классданных
from typing import Self as Сам

import исключения as ис
import токен as тк
from операции import питон
from операции.база import Оп
from программа import Программа
from структуры import ПромежутТаблицаИмен, ТаблицаКонст
from типы import Список, Словарь, Ничего, Мб
from утилиты import Поток, подними_исключение, йота

КОММЕНТАРИЙ = "//"
ОБЪЯВЛЕНИЕ_ПЕРЕМЕННОЙ_РЕГВЫР = r"^заряжаем *([а-яА-Яa-zA-Z]+)( *=)?(.*)?"
ПРИСВОЕНИЕ_РЕГВЫР = r"([а-яА-Яa-zA-Z]+) = (.*)"
ВЫЗОВ_ФУНК_РЕГВЫР = r"(\w+)\((.*)\)"


def _попробуй_получи_вызов(строка: str) -> Мб[тк.Вызов]:
    if соотв := ре.match(ВЫЗОВ_ФУНК_РЕГВЫР, строка):
        имя_функ, аргументы = соотв.groups()
        return тк.Вызов(
            функция=тк.Функция(имя_функ),
            аргументы=_парсить_аргументы(аргументы)
        )
    return Ничего

def _попробуй_получи_вещественное(строка: str) -> Мб[тк.ВещественноеЧисло]:
    if ре.match(r"^-?\d+\.\d+$", строка): 
        return тк.ВещественноеЧисло(float(строка))

def _попробуй_получи_целое(строка: str) -> Мб[тк.ЦелоеЧисло]:
    if строка.isdigit(): 
        return тк.ЦелоеЧисло(int(строка))

def _попробуй_получи_строку(строка: str) -> Мб[тк.Строка]:
    if строка.startswith('"') and строка.endswith('"'): 
        return тк.Строка(строка[1:-1])

def _попробуй_получи_булево(строка: str) -> Мб[тк.Булево]:
    if строка in {"да", "не"}: 
        return тк.Булево(строка == "да")

def _попробуй_получи_объявление(строка: str) -> Мб[тк.ОбъявлениеПеременной]:
    if соотв := ре.match(ОБЪЯВЛЕНИЕ_ПЕРЕМЕННОЙ_РЕГВЫР, строка): 
        знач = Ничего
        if соотв.group(2):
            прав_часть = соотв.group(3)
            знач = получить_токен(прав_часть)
        return тк.ОбъявлениеПеременной(соотв.group(1), знач)

def _попробуй_получи_присвоение(строка: str) -> Мб[тк.Присвоение]:
    if соотв := ре.match(ПРИСВОЕНИЕ_РЕГВЫР , строка):
        перем, знач = соотв.groups()
        return тк.Присвоение(перем, знач)
    return Ничего

def получить_токен(строка: str) -> тк.Токен:
    строка = строка.strip()
    return (
        _попробуй_получи_вызов(строка)
        or _попробуй_получи_вещественное(строка)
        or _попробуй_получи_целое(строка)
        or _попробуй_получи_строку(строка)
        or _попробуй_получи_булево(строка)
        or _попробуй_получи_присвоение(строка)
        or _попробуй_получи_объявление(строка)
        or тк.Переменная(строка)
        # or подними_исключение(ис.ОшибкаПреобразованияТокена(строка))
    )

def _парсить_аргументы(аргументы: str) -> Список[тк.Токен]:
    токены = []
    баланс = 0
    текущие_символы = []
    for симв in аргументы:
        if симв == "," and баланс == 0:
            токены.append(получить_токен("".join(текущие_символы)))
            текущие_символы = []
        else:
            if симв == "(":   баланс += 1
            elif симв == ")": баланс -= 1
            текущие_символы.append(симв)
    if текущие_символы:
        токены.append(получить_токен(''.join(текущие_символы)))
    return токены


def _убрать_комменты(стр: str) -> str:
    if стр.startswith("//"):
        стр = ""
    if (поз_коммент := стр.find(КОММЕНТАРИЙ)) != -1:
        стр = стр[:поз_коммент]
    return стр


def _подготовить_строки(файл: путьбиб.Path) -> Список[str]:
    содержание = файл.read_text()
    return (
        Поток(содержание.splitlines())
        .прим(str.strip)
        .прим(_убрать_комменты)
        .фильтр(bool)
        .собрать(list)
    )


def получить_программу(файл: путьбиб.Path) -> Программа:
    строки = _подготовить_строки(файл)
    токены = (
        Поток(строки)
        .прим(получить_токен)
        .фильтр(bool)
        .собрать(list)
    )
    print("Токены:")
    __import__('pprint').pprint(токены)
    print()
    промежут_табл_им = ПромежутТаблицаИмен()
    таблица_конст = ТаблицаКонст()
    таблица_конст.найти_или_создать(Ничего)
    операции = []
    операции.extend([питон.Вернуть(0)])
    for ток in токены:
        операции.extend(ток.генерир_опы(промежут_табл_им, таблица_конст))
    операции.extend([
        питон.ТянутьВерхушку(),
        питон.ВернутьКонст(таблица_конст.найти_или_создать(Ничего)),
    ])

    таблица_имен = {
        данные.ид: (имя, данные.знач)
        for имя, данные in промежут_табл_им.items()
    }
    конст_пул = tuple(знач for знач in sorted(таблица_конст, key=таблица_конст.get))
    return Программа(операции, таблица_имен, конст_пул)

